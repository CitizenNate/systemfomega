// AUTOGENERATED CODE - DO NOT EDIT
package g
import m.Delay
import m.Viewer
import m.AbstractViewer
import m.Variable
import m.TagApi
import scala.language.higherKinds
import scala.language.implicitConversions
/** MATCH TEMPLATES
Map(ValueType -> List(ExpressionType, PartialType), Val -> List(Expression), Kind -> List(ValueType), ExpressionType -> List(CodeType), PartialType -> List(CodeType))

Expression match {
	case PolyApply(fun,arg) => ???
	case Succ(pred) => ???
	case Num(n) => ???
	case Lambda(annot,x,body) => ???
	case Zero => ???
	case Apply(fun,arg) => ???
	case Triv => ???
	case Fold(base,hypo,step,on) => ???
	case PolyLambda(annot,x,body) => ???
}

Val match {
	case Succ(pred) => ???
	case Num(n) => ???
	case Lambda(annot,x,body) => ???
	case Zero => ???
	case Triv => ???
	case PolyLambda(annot,x,body) => ???
}

CodeType match {
	case Nat => ???
	case Lambda(annot,x,body) => ???
	case Arrow(in,out) => ???
	case Apply(fun,arg) => ???
	case Forall(annot,x,body) => ???
	case Triv => ???
	case Unknown => ???
}

ExpressionType match {
	case Nat => ???
	case Lambda(annot,x,body) => ???
	case Arrow(in,out) => ???
	case Apply(fun,arg) => ???
	case Forall(annot,x,body) => ???
	case Triv => ???
}

PartialType match {
	case Nat => ???
	case Lambda(annot,x,body) => ???
	case Arrow(in,out) => ???
	case Forall(annot,x,body) => ???
	case Triv => ???
	case Unknown => ???
}

ValueType match {
	case Nat => ???
	case Lambda(annot,x,body) => ???
	case Arrow(in,out) => ???
	case Forall(annot,x,body) => ???
	case Triv => ???
}

Kind match {
	case Arrow(in,out) => ???
	case Triv => ???
}
**/
abstract class SyntaxSignature extends AbstractViewer {
	type Expression >: Bottom <: Top with TermApi[Expression]
	type Val >: Bottom <: Top with TermApi[Val] with Expression
	type CodeType >: Bottom <: Top with TermApi[CodeType]
	type ExpressionType >: Bottom <: Top with TermApi[ExpressionType] with CodeType
	type PartialType >: Bottom <: Top with TermApi[PartialType] with CodeType
	type ValueType >: Bottom <: Top with TermApi[ValueType] with ExpressionType with PartialType
	type Kind >: Bottom <: Top with TermApi[Kind] with ValueType
	trait NatExtractor0 {
		def unapply(node:ValueType) : Option[Unit]
	}
	trait NatProducer {
		def apply(): ValueType
	}
	val Nat : NatExtractor0 with NatProducer
	trait PolyApplyExtractor0 {
		def apply(fun: Expression,arg: ExpressionType) : Expression
		def unapply(node:Expression) : Option[(Expression,ExpressionType)]
	}
	val PolyApply : PolyApplyExtractor0
	trait SuccExtractor0 {
		def apply(pred: Val) : Val
		def unapply(node:Val) : Option[(Val)]
	}
	trait SuccExtractor1 {
		def apply(pred: Expression) : Expression
		def unapply(node:Expression) : Option[(Expression)]
	}
	val Succ : SuccExtractor0 with SuccExtractor1
	trait NumExtractor0 {
		def unapply(node:Expression) : Option[(Int)]
	}
	trait NumExtractor1 {
		def apply(n: Int) : Val
		def unapply(node:Val) : Option[(Int)]
	}
	val Num : NumExtractor0 with NumExtractor1
	trait LambdaExtractor0 {
		def apply(annot: CodeType,x: Var[_ >: Val],body: Expression) : Val
		def unapply(node:Val) : Option[(CodeType,Var[Val],Expression)]
	}
	trait LambdaExtractor1 {
		def unapply(node:Expression) : Option[(CodeType,Var[Val],Expression)]
	}
	trait LambdaExtractor2 {
		def apply(annot: Kind,x: Var[_ >: ValueType],body: ExpressionType) : ValueType
		def unapply(node:ValueType) : Option[(Kind,Var[ValueType],ExpressionType)]
	}
	trait LambdaExtractor3 {
		def apply(annot: Kind,x: Var[_ >: ValueType],body: CodeType) : PartialType
		def unapply(node:PartialType) : Option[(Kind,Var[ValueType],CodeType)]
	}
	trait LambdaExtractor4 {
		def unapply(node:ExpressionType) : Option[(Kind,Var[ValueType],ExpressionType)]
	}
	trait LambdaExtractor5 {
		def unapply(node:CodeType) : Option[(Kind,Var[ValueType],CodeType)]
	}
	val Lambda : LambdaExtractor0 with LambdaExtractor1 with LambdaExtractor2 with LambdaExtractor3 with LambdaExtractor4 with LambdaExtractor5
	trait ArrowExtractor0 {
		def apply(in: Kind,out: Kind) : Kind
		def unapply(node:Kind) : Option[(Kind,Kind)]
	}
	trait ArrowExtractor1 {
		def apply(in: CodeType,out: CodeType) : CodeType
		def unapply(node:CodeType) : Option[(CodeType,CodeType)]
	}
	trait ArrowExtractor2 {
		def apply(in: ExpressionType,out: ExpressionType) : ExpressionType
		def unapply(node:ExpressionType) : Option[(ExpressionType,ExpressionType)]
	}
	trait ArrowExtractor3 {
		def apply(in: PartialType,out: PartialType) : PartialType
		def unapply(node:PartialType) : Option[(PartialType,PartialType)]
	}
	trait ArrowExtractor4 {
		def apply(in: ValueType,out: ValueType) : ValueType
		def unapply(node:ValueType) : Option[(ValueType,ValueType)]
	}
	val Arrow : ArrowExtractor0 with ArrowExtractor1 with ArrowExtractor2 with ArrowExtractor3 with ArrowExtractor4
	trait ZeroExtractor0 {
		def unapply(node:Val) : Option[Unit]
	}
	trait ZeroProducer {
		def apply(): Val
	}
	val Zero : ZeroExtractor0 with ZeroProducer
	trait ApplyExtractor0 {
		def apply(fun: Expression,arg: Expression) : Expression
		def unapply(node:Expression) : Option[(Expression,Expression)]
	}
	trait ApplyExtractor1 {
		def apply(fun: CodeType,arg: CodeType) : CodeType
		def unapply(node:CodeType) : Option[(CodeType,CodeType)]
	}
	trait ApplyExtractor2 {
		def apply(fun: ExpressionType,arg: ExpressionType) : ExpressionType
		def unapply(node:ExpressionType) : Option[(ExpressionType,ExpressionType)]
	}
	val Apply : ApplyExtractor0 with ApplyExtractor1 with ApplyExtractor2
	trait ForallExtractor0 {
		def apply(annot: Kind,x: Var[_ >: ValueType],body: CodeType) : CodeType
		def unapply(node:CodeType) : Option[(Kind,Var[ValueType],CodeType)]
	}
	trait ForallExtractor1 {
		def apply(annot: Kind,x: Var[_ >: ValueType],body: ExpressionType) : ExpressionType
		def unapply(node:ExpressionType) : Option[(Kind,Var[ValueType],ExpressionType)]
	}
	trait ForallExtractor2 {
		def apply(annot: Kind,x: Var[_ >: ValueType],body: PartialType) : PartialType
		def unapply(node:PartialType) : Option[(Kind,Var[ValueType],PartialType)]
	}
	trait ForallExtractor3 {
		def apply(annot: Kind,x: Var[_ >: ValueType],body: ValueType) : ValueType
		def unapply(node:ValueType) : Option[(Kind,Var[ValueType],ValueType)]
	}
	val Forall : ForallExtractor0 with ForallExtractor1 with ForallExtractor2 with ForallExtractor3
	trait TrivExtractor0 {
		def unapply(node:Kind) : Option[Unit]
	}
	trait TrivExtractor1 {
		def unapply(node:Val) : Option[Unit]
	}
	trait TrivProducer {
		def apply(): Kind with Val
	}
	val Triv : TrivExtractor0 with TrivExtractor1 with TrivProducer
	trait FoldExtractor0 {
		def apply(base: Expression,hypo: Var[_ >: Val],step: Expression,on: Expression) : Expression
		def unapply(node:Expression) : Option[(Expression,Var[Val],Expression,Expression)]
	}
	val Fold : FoldExtractor0
	trait PolyLambdaExtractor0 {
		def apply(annot: Kind,x: Var[_ >: ValueType],body: Expression) : Val
		def unapply(node:Val) : Option[(Kind,Var[ValueType],Expression)]
	}
	trait PolyLambdaExtractor1 {
		def unapply(node:Expression) : Option[(Kind,Var[ValueType],Expression)]
	}
	val PolyLambda : PolyLambdaExtractor0 with PolyLambdaExtractor1
	trait UnknownExtractor0 {
		def unapply(node:PartialType) : Option[Unit]
	}
	trait UnknownExtractor1 {
		def unapply(node:PartialType) : Option[Unit]
	}
	trait UnknownProducer {
		def apply(): PartialType with PartialType
	}
	val Unknown : UnknownExtractor0 with UnknownExtractor1 with UnknownProducer
	trait VarExtractor0{
		def apply(x:Var[Val]):Val
		def unapply(x:Val):Option[Var[Val]]
	}
	trait VarExtractor1{
		def unapply(x:Expression):Option[Var[Val]]
	}
	trait VarExtractor2{
		def unapply(x:ExpressionType):Option[Var[ValueType]]
	}
	trait VarExtractor3{
		def apply(x:Var[ValueType]):ValueType
		def unapply(x:ValueType):Option[Var[ValueType]]
	}
	trait VarExtractor4{
		def unapply(x:CodeType):Option[Var[ValueType]]
	}
	trait VarExtractor5{
		def unapply(x:PartialType):Option[Var[ValueType]]
	}
	val VarTerm : VarExtractor0 with VarExtractor1 with VarExtractor2 with VarExtractor3 with VarExtractor4 with VarExtractor5
}

abstract class SyntaxStructure extends SyntaxSignature {
import vars._
	trait Top extends TermApi[Top] {
		def sub[B >: Bottom <: Top](b: (Var[B], B)): Top = {
			substitute(b._2, b._1, this)
		}
	}
	type Free <: TagApi[Tag]
	type Var[X]=Free
	override type Bottom = Top
	override type Expression = Top
	override type Val = Top
	override type CodeType = Top
	override type ExpressionType = Top
	override type PartialType = Top
	override type ValueType = Top
	override type Kind = Top
	case object Nat extends NatExtractor0 with NatProducer with Top {
		def apply() : Top = {
			Nat
		}
		def unapply(node:Top) : Option[Unit] = {
			node match { case Nat=>Some() case _ => None }
		}
	}
	case class PolyApplyImpl(fun: (List[Tag],Top),arg: (List[Tag],Top)) extends Top{
		override def productPrefix:String = "PolyApply"
	}
	object PolyApply extends PolyApplyExtractor0 {
		def apply(fun: Top,arg: Top) : Top = {
			PolyApplyImpl(Bind(List(),fun),Bind(List(),arg))
		}
		def unapply(node:Top) : Option[(Top,Top)] = {
			node match { case PolyApplyImpl(Bind(List(),fun),Bind(List(),arg))=>Some((fun,arg)) case _ => None }
		}
	}
	case class SuccImpl(pred: (List[Tag],Top)) extends Top{
		override def productPrefix:String = "Succ"
	}
	object Succ extends SuccExtractor0 with SuccExtractor1 {
		def apply(pred: Top) : Top = {
			SuccImpl(Bind(List(),pred))
		}
		def unapply(node:Top) : Option[(Top)] = {
			node match { case SuccImpl(Bind(List(),pred))=>Some((pred)) case _ => None }
		}
	}
	case class NumImpl(n: Int) extends Top{
		override def productPrefix:String = "Num"
	}
	object Num extends NumExtractor0 with NumExtractor1 {
		def apply(n: Int) : Top = {
			NumImpl(n)
		}
		def unapply(node:Top) : Option[(Int)] = {
			node match { case NumImpl(n)=>Some((n)) case _ => None }
		}
	}
	case class LambdaImpl(annot: (List[Tag],Top),body: (List[Tag],Top)) extends Top{
		override def productPrefix:String = "Lambda"
	}
	object Lambda extends LambdaExtractor0 with LambdaExtractor1 with LambdaExtractor2 with LambdaExtractor3 with LambdaExtractor4 with LambdaExtractor5 {
		def apply(annot: Top,x: Free,body: Top) : Top = {
			LambdaImpl(Bind(List(),annot),Bind(List(x),body))
		}
		def unapply(node:Top) : Option[(Top,Free,Top)] = {
			node match { case LambdaImpl(Bind(List(),annot),Bind(List(x),body))=>Some((annot,x,body)) case _ => None }
		}
	}
	case class ArrowImpl(in: (List[Tag],Top),out: (List[Tag],Top)) extends Top{
		override def productPrefix:String = "Arrow"
	}
	object Arrow extends ArrowExtractor0 with ArrowExtractor1 with ArrowExtractor2 with ArrowExtractor3 with ArrowExtractor4 {
		def apply(in: Top,out: Top) : Top = {
			ArrowImpl(Bind(List(),in),Bind(List(),out))
		}
		def unapply(node:Top) : Option[(Top,Top)] = {
			node match { case ArrowImpl(Bind(List(),in),Bind(List(),out))=>Some((in,out)) case _ => None }
		}
	}
	case object Zero extends ZeroExtractor0 with ZeroProducer with Top {
		def apply() : Top = {
			Zero
		}
		def unapply(node:Top) : Option[Unit] = {
			node match { case Zero=>Some() case _ => None }
		}
	}
	case class ApplyImpl(fun: (List[Tag],Top),arg: (List[Tag],Top)) extends Top{
		override def productPrefix:String = "Apply"
	}
	object Apply extends ApplyExtractor0 with ApplyExtractor1 with ApplyExtractor2 {
		def apply(fun: Top,arg: Top) : Top = {
			ApplyImpl(Bind(List(),fun),Bind(List(),arg))
		}
		def unapply(node:Top) : Option[(Top,Top)] = {
			node match { case ApplyImpl(Bind(List(),fun),Bind(List(),arg))=>Some((fun,arg)) case _ => None }
		}
	}
	case class ForallImpl(annot: (List[Tag],Top),body: (List[Tag],Top)) extends Top{
		override def productPrefix:String = "Forall"
	}
	object Forall extends ForallExtractor0 with ForallExtractor1 with ForallExtractor2 with ForallExtractor3 {
		def apply(annot: Top,x: Free,body: Top) : Top = {
			ForallImpl(Bind(List(),annot),Bind(List(x),body))
		}
		def unapply(node:Top) : Option[(Top,Free,Top)] = {
			node match { case ForallImpl(Bind(List(),annot),Bind(List(x),body))=>Some((annot,x,body)) case _ => None }
		}
	}
	case object Triv extends TrivExtractor0 with TrivExtractor1 with TrivProducer with Top {
		def apply() : Top = {
			Triv
		}
		def unapply(node:Top) : Option[Unit] = {
			node match { case Triv=>Some() case _ => None }
		}
	}
	case class FoldImpl(base: (List[Tag],Top),step: (List[Tag],Top),on: (List[Tag],Top)) extends Top{
		override def productPrefix:String = "Fold"
	}
	object Fold extends FoldExtractor0 {
		def apply(base: Top,hypo: Free,step: Top,on: Top) : Top = {
			FoldImpl(Bind(List(),base),Bind(List(hypo),step),Bind(List(),on))
		}
		def unapply(node:Top) : Option[(Top,Free,Top,Top)] = {
			node match { case FoldImpl(Bind(List(),base),Bind(List(hypo),step),Bind(List(),on))=>Some((base,hypo,step,on)) case _ => None }
		}
	}
	case class PolyLambdaImpl(annot: (List[Tag],Top),body: (List[Tag],Top)) extends Top{
		override def productPrefix:String = "PolyLambda"
	}
	object PolyLambda extends PolyLambdaExtractor0 with PolyLambdaExtractor1 {
		def apply(annot: Top,x: Free,body: Top) : Top = {
			PolyLambdaImpl(Bind(List(),annot),Bind(List(x),body))
		}
		def unapply(node:Top) : Option[(Top,Free,Top)] = {
			node match { case PolyLambdaImpl(Bind(List(),annot),Bind(List(x),body))=>Some((annot,x,body)) case _ => None }
		}
	}
	case object Unknown extends UnknownExtractor0 with UnknownExtractor1 with UnknownProducer with Top {
		def apply() : Top = {
			Unknown
		}
		def unapply(node:Top) : Option[Unit] = {
			node match { case Unknown=>Some() case _ => None }
		}
	}
	case class VarTermImpl(v: Leaf[Free]) extends Top
	case object VarTerm extends VarExtractor0 with VarExtractor1 with VarExtractor2 with VarExtractor3 with VarExtractor4 with VarExtractor5 {
		def apply(x:Free) = VarTermImpl(FreeLeaf(x))
		def unapply(x:Top) = x match {
			case VarTermImpl(FreeLeaf(v))=>Some(v)
			case VarTermImpl(BoundLeaf(_))=> ???
			case _ => None
		}
	}
	def show[T >: Bottom <: Top](term: T):View[T] = term match {
		case Nat =>
			NodeView({case (List(),List()) => Nat },List(),List())
		case PolyApplyImpl(fun,arg) =>
			NodeView({case (List(),List(fun,arg)) => PolyApplyImpl(fun,arg) },List(),List(fun,arg))
		case SuccImpl(pred) =>
			NodeView({case (List(),List(pred)) => SuccImpl(pred) },List(),List(pred))
		case NumImpl(n) =>
			NodeView({case (List(n:Int),List()) => NumImpl(n) },List(n:Int),List())
		case LambdaImpl(annot,body) =>
			NodeView({case (List(),List(annot,body)) => LambdaImpl(annot,body) },List(),List(annot,body))
		case ArrowImpl(in,out) =>
			NodeView({case (List(),List(in,out)) => ArrowImpl(in,out) },List(),List(in,out))
		case Zero =>
			NodeView({case (List(),List()) => Zero },List(),List())
		case ApplyImpl(fun,arg) =>
			NodeView({case (List(),List(fun,arg)) => ApplyImpl(fun,arg) },List(),List(fun,arg))
		case ForallImpl(annot,body) =>
			NodeView({case (List(),List(annot,body)) => ForallImpl(annot,body) },List(),List(annot,body))
		case Triv =>
			NodeView({case (List(),List()) => Triv },List(),List())
		case FoldImpl(base,step,on) =>
			NodeView({case (List(),List(base,step,on)) => FoldImpl(base,step,on) },List(),List(base,step,on))
		case PolyLambdaImpl(annot,body) =>
			NodeView({case (List(),List(annot,body)) => PolyLambdaImpl(annot,body) },List(),List(annot,body))
		case Unknown =>
			NodeView({case (List(),List()) => Unknown },List(),List())
		case VarTermImpl(v) => LeafView(v)
	}
	def hide[T >: Bottom <: Top](view:View[T]):T = view match {
		case NodeView(tag,constant,children)=> tag(constant,children)
		case LeafView(v) => VarTermImpl(v)
	}
}

